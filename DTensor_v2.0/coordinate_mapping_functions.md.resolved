# DeviceMesh Coordinate Mapping: Complete Guide

## Overview

The DeviceMesh class uses **row-major ordering** to map between 1D global ranks and n-dimensional mesh coordinates. This document explains all four coordinate mapping functions in detail.

---

## Function 1: [get_coordinate(rank)](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#58-70) - Rank → Coordinates

### Purpose
Convert a global MPI rank (0-indexed) to its n-dimensional mesh coordinates.

### Code Implementation

```cpp
std::vector<int> DeviceMesh::get_coordinate(int rank) const {
    std::vector<int> coord(ndim());
    int remaining = rank;
    
    // Row-major ordering: rightmost dimension varies fastest
    for (int dim = ndim() - 1; dim >= 0; --dim) {
        coord[dim] = remaining % mesh_shape_[dim];
        remaining /= mesh_shape_[dim];
    }
    
    return coord;
}
```

### Mathematical Formula

For a mesh with shape `[D₀, D₁, ..., Dₙ₋₁]` and rank `r`:

```
coord[n-1] = r mod Dₙ₋₁
coord[n-2] = (r / Dₙ₋₁) mod Dₙ₋₂
coord[n-3] = (r / (Dₙ₋₁ × Dₙ₋₂)) mod Dₙ₋₃
...
coord[0] = r / (D₁ × D₂ × ... × Dₙ₋₁)
```

### Example 1: [2, 4] Mesh (8 ranks)

**Mesh Shape:** `[2, 4]` (2 rows, 4 columns)

```
Visual Layout:
     Col 0  Col 1  Col 2  Col 3
Row 0: [0]    [1]    [2]    [3]
Row 1: [4]    [5]    [6]    [7]
```

**Step-by-Step for Rank 5:**

```  cpp
mesh_shape_ = [2, 4]
ndim() = 2
rank = 5

coord = [?, ?]
remaining = 5

// Iteration 1: dim = 1 (rightmost, varies fastest)
coord[1] = remaining % mesh_shape_[1]
        = 5 % 4
        = 1  ✓ (Column 1)

remaining = remaining / mesh_shape_[1]
         = 5 / 4
         = 1

// Iteration 2: dim = 0
coord[0] = remaining % mesh_shape_[0]
        = 1 % 2
        = 1  ✓ (Row 1)

remaining = remaining / mesh_shape_[0]
         = 1 / 2
         = 0  (done)

Result: coord = [1, 1]
```

**All Ranks for [2, 4] Mesh:**

| Rank |    Calculation      | Coordinate |
|------|---------------------|------------|
| 0    | [0%2, 0%4] = [0, 0] |   [0, 0]   |
| 1    | [0%2, 1%4] = [0, 1] |   [0, 1]   |
| 2    | [0%2, 2%4] = [0, 2] |   [0, 2]   |
| 3    | [0%2, 3%4] = [0, 3] |   [0, 3]   |
| 4    | [1%2, 4%4] = [1, 0] |   [1, 0]   |
| 5    | [1%2, 5%4] = [1, 1] |   [1, 1]   |
| 6    | [1%2, 6%4] = [1, 2] |   [1, 2]   |
| 7    | [1%2, 7%4] = [1, 3] |   [1, 3]   |

### Example 2: [2, 2, 2] Mesh (8 ranks, 3D)

**Mesh Shape:** `[2, 2, 2]` (2×2×2 cube)

```
Visual Layout:
  Layer 0 (dim0=0):        Layer 1 (dim0=1):
    [0] [1]                  [4] [5]
    [2] [3]                  [6] [7]
```

**Step-by-Step for Rank 6:**

```cpp
mesh_shape_ = [2, 2, 2]
ndim() = 3
rank = 6

coord = [?, ?, ?]
remaining = 6

// Iteration 1: dim = 2 (rightmost)
coord[2] = 6 % 2 = 0  ✓
remaining = 6 / 2 = 3

// Iteration 2: dim = 1
coord[1] = 3 % 2 = 1  ✓
remaining = 3 / 2 = 1

// Iteration 3: dim = 0 (leftmost)
coord[0] = 1 % 2 = 1  ✓
remaining = 1 / 2 = 0

Result: coord = [1, 1, 0]
```

**All Ranks for [2, 2, 2] Mesh:**

| Rank | Coordinate | Position |
|------|------------|----------|
| 0    | [0, 0, 0]  | Layer 0, top-left, front |
| 1    | [0, 0, 1]  | Layer 0, top-left, back |
| 2    | [0, 1, 0]  | Layer 0, bottom-left, front |
| 3    | [0, 1, 1]  | Layer 0, bottom-left, back |
| 4    | [1, 0, 0]  | Layer 1, top-left, front |
| 5    | [1, 0, 1]  | Layer 1, top-left, back |
| 6    | [1, 1, 0]  | Layer 1, bottom-left, front |
| 7    | [1, 1, 1]  | Layer 1, bottom-left, back |

---

## Function 2: [get_rank(coordinate)](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#71-90) - Coordinates → Rank

### Purpose
Convert n-dimensional mesh coordinates to a global MPI rank. **Inverse of [get_coordinate()](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#58-70).**

### Code Implementation

```cpp
int DeviceMesh::get_rank(const std::vector<int>& coordinate) const {
    if ((int)coordinate.size() != ndim()) {
        throw std::runtime_error("DeviceMesh: coordinate size must match mesh ndim");
    }
    
    int rank = 0;
    int stride = 1;
    
    // Row-major ordering
    for (int dim = ndim() - 1; dim >= 0; --dim) {
        if (coordinate[dim] < 0 || coordinate[dim] >= mesh_shape_[dim]) {
            throw std::runtime_error("DeviceMesh: coordinate out of bounds");
        }
        rank += coordinate[dim] * stride;
        stride *= mesh_shape_[dim];
    }
    
    return rank;
}
```

### Mathematical Formula

For coordinates `[c₀, c₁, ..., cₙ₋₁]` in mesh `[D₀, D₁, ..., Dₙ₋₁]`:

```
rank = c₀ × (D₁ × D₂ × ... × Dₙ₋₁)
     + c₁ × (D₂ × D₃ × ... × Dₙ₋₁)
     + c₂ × (D₃ × D₄ × ... × Dₙ₋₁)
     + ...
     + cₙ₋₂ × Dₙ₋₁
     + cₙ₋₁
```

### Example 1: [2, 4] Mesh - Coordinate [1, 2]

```cpp
mesh_shape_ = [2, 4]
coordinate = [1, 2]
ndim() = 2

rank = 0
stride = 1

// Iteration 1: dim = 1 (rightmost)
rank += coordinate[1] * stride
     += 2 * 1
     = 2

stride *= mesh_shape_[1]
       *= 4
       = 4

// Iteration 2: dim = 0
rank += coordinate[0] * stride
     += 1 * 4
     = 6

stride *= mesh_shape_[0]
       = 4 * 2
       = 8 (not used)

Result: rank = 6  ✓
```

**Verification:**
```
[1, 2] means Row 1, Column 2
Visual:
     Col 0  Col 1  Col 2  Col 3
Row 0: [0]    [1]    [2]    [3]
Row 1: [4]    [5]    [6]←   [7]

Rank 6 is indeed at [1, 2] ✓
```

### Example 2: [2, 2, 2] Mesh - Coordinate [1, 0, 1]

```cpp
mesh_shape_ = [2, 2, 2]
coordinate = [1, 0, 1]
ndim() = 3

rank = 0
stride = 1

// Iteration 1: dim = 2
rank += 1 * 1 = 1
stride = 1 * 2 = 2

// Iteration 2: dim = 1
rank += 0 * 2 = 1 (unchanged)
stride = 2 * 2 = 4

// Iteration 3: dim = 0
rank += 1 * 4 = 5
stride = 4 * 2 = 8

Result: rank = 5  ✓
```

### Stride Pattern Explanation

The `stride` represents **how many ranks you skip** when moving by 1 in that dimension:

```
For [2, 4] mesh:
- Moving 1 in dim 1 (column): stride = 1
- Moving 1 in dim 0 (row): stride = 4 (jump entire row)

For [2, 2, 2] mesh:
- Moving 1 in dim 2: stride = 1
- Moving 1 in dim 1: stride = 2 (jump one row in a slice)
- Moving 1 in dim 0: stride = 4 (jump entire layer)
```

---

## Function 3: [get_group_ranks(mesh_dim)](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#92-108) - Process Group Members

### Purpose
Get all global ranks that belong to the **same process group** for a specific mesh dimension. These are ranks that differ **only** in the `mesh_dim` coordinate.

### Code Implementation

```cpp
std::vector<int> DeviceMesh::get_group_ranks(int mesh_dim) const {
    if (mesh_dim < 0 || mesh_dim >= ndim()) {
        throw std::runtime_error("DeviceMesh: invalid mesh_dim");
    }
    
    std::vector<int> ranks;
    
    // All ranks that differ only in mesh_dim coordinate
    std::vector<int> base_coord = my_coordinate_;
    
    for (int i = 0; i < mesh_shape_[mesh_dim]; ++i) {
        base_coord[mesh_dim] = i;
        ranks.push_back(get_rank(base_coord));
    }
    
    return ranks;
}
```

### Conceptual Explanation

For a rank at coordinate `[c₀, c₁, ..., cₙ₋₁]`, its process group for `mesh_dim=d` contains all ranks at:

```
[c₀, c₁, ..., c_{d-1}, *, c_{d+1}, ..., cₙ₋₁]
                       ↑
                  varies from 0 to D_d - 1
```

### Example 1: [2, 4] Mesh - Rank 5 [1, 1]

**For mesh_dim=0 (Row communication):**

```cpp
my_coordinate_ = [1, 1]
mesh_dim = 0
mesh_shape_[0] = 2

base_coord = [1, 1]  // Start with my coordinate

// Iteration 1: i = 0
base_coord[0] = 0  → [0, 1]
rank = get_rank([0, 1]) = 1
ranks.push_back(1)

// Iteration 2: i = 1
base_coord[0] = 1  → [1, 1]
rank = get_rank([1, 1]) = 5
ranks.push_back(5)

Result: {1, 5}  ✓
```

**Visual:**
```
     Col 0  Col 1  Col 2  Col 3
Row 0: [0]   →[1]←   [2]    [3]
                ↕
Row 1: [4]   →[5]←   [6]    [7]

Rank 5's group for dim 0: {1, 5} (same column)
```

**For mesh_dim=1 (Column communication):**

```cpp
my_coordinate_ = [1, 1]
mesh_dim = 1
mesh_shape_[1] = 4

base_coord = [1, 1]

// Iteration: i = 0, 1, 2, 3
base_coord[1] = 0 → [1, 0] → rank 4
base_coord[1] = 1 → [1, 1] → rank 5
base_coord[1] = 2 → [1, 2] → rank 6
base_coord[1] = 3 → [1, 3] → rank 7

Result: {4, 5, 6, 7}  ✓
```

**Visual:**
```
     Col 0  Col 1  Col 2  Col 3
Row 0: [0]    [1]    [2]    [3]

Row 1:→[4]←→→[5]←→→[6]←→→[7]←
      (all in same row, Rank 5's group for dim 1)
```

### Example 2: Complete Group Table for [2, 4] Mesh

| Rank | Coord  | Groups for dim 0 | Groups for dim 1 |
|------|--------|------------------|------------------|
| 0    | [0,0]  | {0, 4}          | {0, 1, 2, 3}    |
| 1    | [0,1]  | {1, 5}          | {0, 1, 2, 3}    |
| 2    | [0,2]  | {2, 6}          | {0, 1, 2, 3}    |
| 3    | [0,3]  | {3, 7}          | {0, 1, 2, 3}    |
| 4    | [1,0]  | {0, 4}          | {4, 5, 6, 7}    |
| 5    | [1,1]  | {1, 5}          | {4, 5, 6, 7}    |
| 6    | [1,2]  | {2, 6}          | {4, 5, 6, 7}    |
| 7    | [1,3]  | {3, 7}          | {4, 5, 6, 7}    |

**Pattern:**
- **Dim 0 groups:** Same column (4 groups of 2 ranks each)
- **Dim 1 groups:** Same row (2 groups of 4 ranks each)

---

## Function 4: [get_dim_rank(mesh_dim)](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#109-115) - Rank Within Dimension

### Purpose
Get this rank's **coordinate value** along a specific mesh dimension. Simply extracts `my_coordinate_[mesh_dim]`.

### Code Implementation

```cpp
int DeviceMesh::get_dim_rank(int mesh_dim) const {
    if (mesh_dim < 0 || mesh_dim >= ndim()) {
        throw std::runtime_error("DeviceMesh: invalid mesh_dim");
    }
    return my_coordinate_[mesh_dim];
}
```

### Example: [2, 4] Mesh

```cpp
// Rank 5 has coordinate [1, 1]

get_dim_rank(0) = my_coordinate_[0] = 1  (Row 1)
get_dim_rank(1) = my_coordinate_[1] = 1  (Column 1)
```

**All Ranks:**

| Rank | Coordinate | get_dim_rank(0) | get_dim_rank(1) |
|------|------------|-----------------|-----------------|
|  0   |   [0, 0]   |        0        |        0        |
|  1   |   [0, 1]   |        0        |        1        |
|  2   |   [0, 2]   |        0        |        2        |
|  3   |   [0, 3]   |        0        |        3        |
|  4   |   [1, 0]   |        1        |        0        |
|  5   |   [1, 1]   |        1        |        1        |
|  6   |   [1, 2]   |        1        |        2        |
|  7   |   [1, 3]   |        1        |        3        |

**Use Case:**
```cpp
// Determine if this rank is the "root" along a dimension
if (device_mesh->get_dim_rank(0) == 0) {
    // This rank is in the first row
}

// Or for load balancing
int my_col = device_mesh->get_dim_rank(1);
process_data_slice(my_col);
```

---

## Verification: Round-Trip Consistency

### Property to Verify:
```
get_rank(get_coordinate(r)) == r  (for all valid r)
get_coordinate(get_rank(c)) == c  (for all valid c)
```

### Test for [2, 4] Mesh:

```cpp
// Forward: rank → coord → rank
for (int r = 0; r < 8; r++) {
    auto coord = get_coordinate(r);
    int rank_back = get_rank(coord);
    assert(rank_back == r);  // ✓ All pass
}

// Backward: coord → rank → coord
for (int i = 0; i < 2; i++) {
    for (int j = 0; j < 4; j++) {
        std::vector<int> coord = {i, j};
        int r = get_rank(coord);
        auto coord_back = get_coordinate(r);
        assert(coord_back == coord);  // ✓ All pass
    }
}
```

---

## Edge Cases and Error Handling

### 1. Out-of-Bounds Rank

```cpp
// Mesh [2, 4] only has 8 ranks (0-7)
auto coord = get_coordinate(8);  // ❌ Undefined behavior

// Should add validation:
assert(rank >= 0 && rank < total_devices_);
```

### 2. Invalid Coordinate

```cpp
// Invalid coordinate [2, 0] (row 2 doesn't exist)
int r = get_rank({2, 0});
// ✓ Throws: "DeviceMesh: coordinate out of bounds"
```

### 3. Dimension Mismatch

```cpp
// Mesh is [2, 4] (2D), but coordinate is 3D
int r = get_rank({1, 2, 0});
// ✓ Throws: "DeviceMesh: coordinate size must match mesh ndim"
```

---

## Performance Characteristics

### Time Complexity:

| Function | Complexity | Reason |
|----------|------------|--------|
| [get_coordinate(rank)](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#58-70) | O(ndim) | One division per dimension |
| [get_rank(coord)](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#71-90) | O(ndim) | One multiplication per dimension |
| [get_group_ranks(mesh_dim)](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#92-108) | O(mesh_shape[mesh_dim] × ndim) | Calls get_rank for each member |
| [get_dim_rank(mesh_dim)](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#109-115) | O(1) | Direct array access |

### Space Complexity:

- [get_coordinate](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#58-70): O(ndim) for result vector
- [get_rank](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#71-90): O(1)
- [get_group_ranks](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#92-108): O(mesh_shape[mesh_dim]) for result vector
- [get_dim_rank](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#109-115): O(1)

---

## Summary Table

| Function | Input | Output | Purpose |
|----------|-------|--------|---------|
| [get_coordinate(rank)](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#58-70) | int | vector<int> | Rank → Coordinates |
| [get_rank(coord)](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#71-90) | vector<int> | int | Coordinates → Rank |
| [get_group_ranks(dim)](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#92-108) | int | vector<int> | Process group members for dimension |
| [get_dim_rank(dim)](file:///home/blu-bridge25/Study/Code/Tensor_Parallelism_impl/tenosr%20parallelism%20/TensorParallelismBeta/DTensor_v2.0/tensor/device_mesh.cpp#109-115) | int | int | My position along dimension |

### Usage Example:

```cpp
DeviceMesh mesh({2, 4});  // 8 ranks in 2×4 grid

// Rank 5 discovers its position
auto coord = mesh.get_coordinate(5);  // [1, 1]

// Find its process group for row communication (dim 0)
auto row_group = mesh.get_group_ranks(0);  // {1, 5}

// Find its process group for column communication (dim 1)
auto col_group = mesh.get_group_ranks(1);  // {4, 5, 6, 7}

// Check if it's in the first row
if (mesh.get_dim_rank(0) == 0) {
    // No, rank 5 is in row 1
}

// Convert back to verify
int rank_check = mesh.get_rank(coord);  // 5 ✓
```

These four functions form the foundation of n-dimensional mesh topology management!
